@model dynamic

<div class="row" >
    <div style="  position: fixed;
    top: 50%;
    left: 50%;
    -webkit-transform: translate(-50%, -50%);
    transform: translate(-50%, -50%);">
        <form id="newCall" style="color: white">
            <span class="lead">Your name:</span><br/>
            <input type="text" id="userName" name="userName"/><br/>
            Conference code:<br />
            <input type="text" id="pinCode" name="pinCode"/><br/>
            <button class="btn btn-default" id="call">Join conference</button>
            <button class="btn btn-default" id="hangup">Hangup</button>
            <audio id="incoming" autoplay></audio>
            <audio id="ringback" src='~/content/ringback.wav' loop></audio>
            <audio id="ringtone" src='~/content/phone_ring.wav' loop></audio>
        </form>
        <div id="callLog">
        </div>
    </div>
</div>


@section scripts
{
    <style>
        body {
            background-image: url('/content/confbg.png');
            background-size: cover;
            background-repeat: no-repeat;
        }
    </style>
    <script src="~/Scripts/sinch.min.js"></script>
    <script>
        /*** Set up sinchClient ***/
        $('#hangup').hide();
        
        sinchClient = new SinchClient({
            applicationKey: '@ViewBag.applicationKey',
            capabilities: { calling: true },
            startActiveConnection: true, /* NOTE: This is required if application is to receive calls / instant messages. */
            //Note: For additional loging, please uncomment the three rows below
            onLogMessage: function (message) {
                console.log(message);
            }
        });

        /*** Define listener for managing calls ***/
        var callListeners = {
            onCallProgressing: function (call) {
                $('audio#ringback').prop("currentTime", 0);
                $('audio#ringback').trigger("play");
                $('#call').hide();
                $('#hangup').show();
                //Report call stats
                $('div#callLog').append('<div id="stats">Ringing...</div>');
            },
            onCallEstablished: function (call) {
                $('audio#incoming').attr('src', call.incomingStreamURL);
                $('audio#ringback').trigger("pause");
                $('audio#ringtone').trigger("pause");

                //Report call stats
                var callDetails = call.getDetails();
                $('div#callLog').append('<div id="stats">Answered at: ' + (callDetails.establishedTime) + '</div>');
            },
            onCallEnded: function (call) {
                $('audio#ringback').trigger("pause");
                $('audio#ringtone').trigger("pause");
                $('audio#incoming').attr('src', '');

                $('button').removeClass('incall');
                $('button').removeClass('callwaiting');
                $('#call').show();
                $('#hangup').hide();
                //Report call stats
                var callDetails = call.getDetails();
                $('div#callLog').append('<div id="stats">Ended: ' + callDetails.endedTime + '</div>');
                $('div#callLog').append('<div id="stats">Duration (s): ' + callDetails.duration + '</div>');
                $('div#callLog').append('<div id="stats">End cause: ' + call.getEndCause() + '</div>');
                if (call.error) {
                    $('div#callLog').append('<div id="stats">Failure message: ' + call.error.message + '</div>');
                }
            }
        }

        /*** Set up callClient and define how to handle incoming calls ***/

        var callClient = sinchClient.getCallClient();
        callClient.initStream().then(function () { // Directly init streams, in order to force user to accept use of media sources at a time we choose
            $('div.frame').not('#chromeFileWarning').show();
        });
        var call;
        var started = false;
        /*** Make a new data call ***/

        $('button#call').click(function (event) {
            event.preventDefault();
            if (!started) {
                $.getJSON("getTicket", { id: $('#userName').val() }, function(ticket) {
                    sinchClient.start(ticket).then(
                        function () {
                            started = true;
                            joinConference();
                        });
                });
            } else {
                joinConference();
            }
          
        });

        function joinConference() {
            //Store session & manage in some way (optional)
            if (!$(this).hasClass("incall") && !$(this).hasClass("callwaiting")) {
                clearError();
                $('button').addClass('incall');
                $('div#callLog').append('<div id="title">Joining conference ' + $('#pinCode').val() + '</div>');
                call = callClient.callConference($('#pinCode').val());
                call.addEventListener(callListeners);
            }
        }
        /*** Hang up a call ***/

        $('button#hangup').click(function (event) {
            event.preventDefault();

            if ($(this).hasClass("incall")) {
                clearError();

                console.info('Will request hangup..');

                call && call.hangup();
            }
        });


        /** Always clear errors **/
        var clearError = function () {
            $('div.error').hide();
        }

        /** Chrome check for file - This will warn developers of using file: protocol when testing WebRTC **/
        if (location.protocol == 'file:' && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
            $('div#chromeFileWarning').show();
        }

        $('button').prop('disabled', false); //Solve Firefox issue, ensure buttons always clickable after load
    </script>

}
